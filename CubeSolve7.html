<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>3x3 cube solve with orbital camera controls.</title>
		<style>
			body { margin: 0; }
			// canvas { width: 200; height: 200 }
			// canvas { width: 100%; height: 100% }
		</style>
	</head>

	<body>
		<script src="https://code.jquery.com/jquery-2.1.0.js"></script>
		<script src="https://threejs.org/build/three.js"></script>
		<script>
			// At start: 
			// 		X-axis is left/right.
			// 		Y-axis is up/down.
			// 		Z-axis is in/out of screen.

			var RENDER_DISTANCE = 2000;		// Render distance and grid size in pixels
			var ORIGIN = new THREE.Vector3(0,0,0); 

			var GRID_SPACE 			= 50;	// Grid space in pixels
			var GRID_POSITION_Y 	= -100;	// Grid position below origin.

			var CAM_ZOOM_SPEED 		= 10;	// Rate of camera radius change.
			var MIN_CAM_RADIUS 		= 20; 	// Minimum camera distance from origin (0,0,0).
			var CAM_START_RADIUS 	= 200;  // Starting camera distance from origin (0,0,0).
			var MAX_CAM_RADIUS 		= 300; 	// Maximum camera distance from origin (0,0,0).

			var CAM_START_POLAR 	= Math.PI / 12;
			var CAM_START_AZIMUTH 	= Math.PI / 12; 
			var CAM_ROTATE_SPEED 	= 0.02; // Camera rotation speed radians per key press

			var UNIT_CUBE_SIZE = 10;
			var CUBE_ROTATE_SPEED 	= Math.PI / 128; // Cube rotation speeed radians per frame

			var XAXIS = new THREE.Vector3(1, 0, 0);		// Rotate on this axis for pitch. Translate to move right (left).
			var YAXIS = new THREE.Vector3(0, 1, 0);		// Rotate on this axis for yaw. Translate to move up (down).
			var ZAXIS = new THREE.Vector3(0, 0, 1);		// Rotate on this for roll. Translate to move backward (forward).

			// Detect key presses and set camera movement & rotation speed.
			var keyNames = {
				32: "space", 
				37: "left", 
				38: "up", 
				39: "right", 
				40: "down", 
				65: "a", 
				66: "b",
				68: "d",
				70: "f",
				76: "l",
				82: "r", 
				83: "s",
				85: "u", 
				87: "w",
				88: "x",
				89: "y",
				90: "z"
			}; 

			var camPolarAngle = CAM_START_POLAR; 				// Horizontal rotation (longitude) in radians
			var camAzimuthAngle = CAM_START_AZIMUTH;			// Vertical rotation (latitude) in radians
			var camRadius = CAM_START_RADIUS;					// Distance from origin (0,0,0) to camera

			$("body").keydown(function (event) {
				// Use arrow keys to rotate camera.
				if (keyNames[event.keyCode] === "left") {
					camPolarAngle += -CAM_ROTATE_SPEED;
				}
				if (keyNames[event.keyCode] === "right") {
					camPolarAngle += CAM_ROTATE_SPEED;
				}
				if (keyNames[event.keyCode] === "up") {
					if ( camAzimuthAngle < Math.PI / 2 ) {
						camAzimuthAngle += CAM_ROTATE_SPEED;
					} else {
						camAzimuthAngle = Math.PI / 2; 
					}
				}
				if (keyNames[event.keyCode] === "down") {
					if ( camAzimuthAngle > -Math.PI / 2 ) {
						camAzimuthAngle -= CAM_ROTATE_SPEED;
					} else {
						camAzimuthAngle = -Math.PI / 2; 
					}
				}
				// Use w and s keys to zoom camera in and out.
				if (keyNames[event.keyCode] === "w") {
					if ( camRadius > MIN_CAM_RADIUS ) {
						camRadius -= CAM_ZOOM_SPEED;
					} else {
						camRadius = MIN_CAM_RADIUS; 
					}
				}
				if (keyNames[event.keyCode] === "s") {
					if ( camRadius < MAX_CAM_RADIUS ) {
						camRadius += CAM_ZOOM_SPEED;
					} else {
						camRadius = MAX_CAM_RADIUS; 
					}
				}
				// Use f, r, u, l, b, d keys to trigger face rotations.
				if (keyNames[event.keyCode] === "f") {
					multiCube3.rotateFacePartial( multiCube3.faceF, ZAXIS, -CUBE_ROTATE_SPEED );
				}
				if (keyNames[event.keyCode] === "r") {
					multiCube3.rotateFacePartial( multiCube3.faceR, XAXIS, -CUBE_ROTATE_SPEED );
				}
				if (keyNames[event.keyCode] === "u") {
					multiCube3.rotateFacePartial( multiCube3.faceU, YAXIS, -CUBE_ROTATE_SPEED );
				}
				if (keyNames[event.keyCode] === "l") {
					multiCube3.rotateFacePartial( multiCube3.faceL, XAXIS, CUBE_ROTATE_SPEED );
				}
				if (keyNames[event.keyCode] === "b") {
					multiCube3.rotateFacePartial( multiCube3.faceB, ZAXIS, CUBE_ROTATE_SPEED );
				}
				if (keyNames[event.keyCode] === "d") {
					multiCube3.rotateFacePartial( multiCube3.faceD, YAXIS, CUBE_ROTATE_SPEED );
				}
			})				

			// Create a camera.
			var camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, RENDER_DISTANCE );
			camera.position.x = 0;
			camera.position.y = 0;
			camera.position.z = CAM_START_RADIUS;
			camera.lookAt(ORIGIN);

			// Create a scene and add fog to it
			var scene = new THREE.Scene();
			scene.fog = new THREE.FogExp2( 0xa8d7ff, 0.0008 );

			// Let there be light!
			var sunLight = new THREE.DirectionalLight( 0xffffff, 0.2 );
			sunLight.position.set(200, 1000, 200);
			sunLight.castShadow = true;
			sunLight.shadow.camera.near = 1;
			sunLight.shadow.camera.far = RENDER_DISTANCE;
			sunLight.shadow.camera.left = -RENDER_DISTANCE / 10;
			sunLight.shadow.camera.right = RENDER_DISTANCE / 10;
			sunLight.shadow.camera.bottom = -RENDER_DISTANCE / 10;
			sunLight.shadow.camera.top = RENDER_DISTANCE / 10;
			sunLight.shadow.mapSize.width = RENDER_DISTANCE / 10;
			sunLight.shadow.mapSize.height = RENDER_DISTANCE / 10;
			scene.add(sunLight);

			var ambientLight = new THREE.AmbientLight( 0xffffff, 2);
			scene.add(ambientLight)

			// Create helpers
			// var shadowHelper = new THREE.CameraHelper( sunLight.shadow.camera );
			// scene.add(shadowHelper);

			// Create plane and grid for ground.
			var grid = new THREE.GridHelper( 10*RENDER_DISTANCE, 10*RENDER_DISTANCE/GRID_SPACE, 0xd00000, 0x101010 );
			grid.position.y = GRID_POSITION_Y;
			scene.add(grid);

			var planeGeo = new THREE.PlaneGeometry( 10*RENDER_DISTANCE, 10*RENDER_DISTANCE, 100, 100 );
			var planeMat = new THREE.MeshStandardMaterial( { color: 0x009900 });					
			var planeGround = new THREE.Mesh( planeGeo, planeMat );
			planeGround.rotation.x = -Math.PI / 2;
			planeGround.position.y = GRID_POSITION_Y - 2;
			scene.add(planeGround);
			planeGround.receiveShadow = true; 

			// MultiCube3
			// Define a 3x3x3 array of multi-colored cubes
			// Starting positions: 
			// Front face (blue)
			//	   24 25 26
			//     21 22 23
			//     18 19 20
			// Middle slice
			//	   15 16 17
			//     12 13 14
			//      9 10 11			
			// Back face (green) as viewed from front
			// 		6  7  8
			// 		3  4  5
			// 		0  1  2
			// Centers of faces are: 
			//   4 = green, 10 = white, 12 = orange 
			// 	13 = (true center of MultiCube3) 
			// 	14 = red, 16 = yellow, 22 = blue
			var MultiCube3 = function ( unitCubeSize ) {
				this.unitCubeSize = unitCubeSize;
				this.unitGeo = new THREE.BoxGeometry( unitCubeSize, unitCubeSize, unitCubeSize );
				this.unitGeo.faces[0].color.setHex( 0xff0000 );	// Red
				this.unitGeo.faces[1].color.setHex( 0xff0000 ); // Red
				this.unitGeo.faces[2].color.setHex( 0xff8c00 ); // Orange
				this.unitGeo.faces[3].color.setHex( 0xff8c00 ); // Orange
				this.unitGeo.faces[4].color.setHex( 0xffff00 ); // Yellow
				this.unitGeo.faces[5].color.setHex( 0xffff00 ); // Yellow
				this.unitGeo.faces[6].color.setHex( 0xffffff ); // White
				this.unitGeo.faces[7].color.setHex( 0xffffff ); // White
				this.unitGeo.faces[8].color.setHex( 0x0000ff ); // Blue
				this.unitGeo.faces[9].color.setHex( 0x0000ff ); // Blue
				this.unitGeo.faces[10].color.setHex( 0x00cc11 ); // Green
				this.unitGeo.faces[11].color.setHex( 0x00cc11 ); // Green
				this.unitMat = new THREE.MeshStandardMaterial( { vertexColors: THREE.FaceColors } );

				this.cubes = [];
				var i = 0;
				for (var z = -1; z <= 1; z++) {
					for (var y = -1; y <= 1; y++) {
						for (var x = -1; x <= 1; x++) {
							this.cubes.push(new THREE.Mesh( this.unitGeo, this.unitMat ));
							this.cubes[i].position.x = x * (unitCubeSize + 1);
							this.cubes[i].position.y = y * (unitCubeSize + 1);
							this.cubes[i].position.z = z * (unitCubeSize + 1);
							this.cubes[i].castShadow = true;
							i++;
						}; 
					}; 
				}; 
				this.faceF = [		// Define front face (blue).
					[24, 25, 26], 
					[21, 22, 23], 
					[18, 19, 20], 
				];
				this.faceR = [		// Define right face (red).
					[26, 17,  8], 
					[23, 14,  5], 
					[20, 11,  2], 
				];
				this.faceU = [		// Define up face (yellow).
					[ 6,  7,  8], 
					[15, 16, 17], 
					[24, 25, 26], 
				];
				this.faceL = [		// Define left face (orange).
					[ 6, 15, 24], 
					[ 3, 12, 21], 
					[ 0,  9, 18], 
				];
				this.faceB = [		// Define back face (green).
					[ 8,  7,  6], 
					[ 5,  4,  3], 
					[ 2,  1,  0], 
				];
				this.faceD = [		// Define down face (white).
					[18, 19, 20], 
					[ 9, 10, 11], 
					[ 0,  1,  2], 
				];
			}; 

			// Define a method for adding a MultiCube3 to a scene.
			MultiCube3.prototype.addToScene = function( scene ) {
				for (var i = 0; i <= 26; i++) {
					scene.add(this.cubes[i]);
				};
			};

			// Define a method for rotating a face of a MultiCube3.
			MultiCube3.prototype.rotateFacePartial = function( face, axis, angle ) {
				var i = j = k = 0;
				var q = new THREE.Quaternion();
				q.setFromAxisAngle(axis, angle);
				for (i=0; i<=2; i++) {
					for (j=0; j<=2; j++) {
							k = face[i][j];
							this.cubes[k].applyQuaternion(q);
							this.cubes[k].position.applyQuaternion(q);
					};
				};
			}; 

			MultiCube3.prototype.rotateFace = function( faceName, stepCount ) {
				switch(faceName) {
					case "F":
						face = this.faceF;
				}				
				for (var i=0; i<=stepCount; i++) {
					this.rotateFacePartial( face, axis, angle );
				};
			};

			// Create the MultiCube3 and add it to the scene.			
			multiCube3 = new MultiCube3( UNIT_CUBE_SIZE ); 
			multiCube3.addToScene( scene );

			// Create a renderer.
			var renderer = new THREE.WebGLRenderer(); 
			renderer.setSize( window.innerWidth - 10, window.innerHeight - 10 ); // Shrunk by 10 pixels to avoid shifts in screen when arrows are used.
			renderer.setClearColor( 0xa8d7ff, 1 ); // Set clear color to sky blue.
			renderer.shadowMap.enabled = true;
			renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
			document.body.appendChild( renderer.domElement );

			// Repeatedly render the scene from the camera's point of view.
			renderer.render( scene, camera );
			function animate() {
				requestAnimationFrame( animate );

				// Move the camera according to user command.
				camera.position.z = camRadius * Math.cos(camAzimuthAngle) * Math.cos(camPolarAngle);
				camera.position.x = camRadius * Math.cos(camAzimuthAngle) * Math.sin(camPolarAngle);
				camera.position.y = camRadius * Math.sin(camAzimuthAngle);
				camera.lookAt(ORIGIN); 

				renderer.render( scene, camera );
			}
			animate(); 
		</script>
	</body>
</html>
