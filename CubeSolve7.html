<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>3x3 cube solve with orbital camera controls.</title>
		<style>
			body { margin: 0; }
			// canvas { width: 200; height: 200 }
			// canvas { width: 100%; height: 100% }
		</style>
	</head>

	<body>
		<script src="https://code.jquery.com/jquery-2.1.0.js"></script>
		<script src="https://threejs.org/build/three.js"></script>
		<script>
			// Define constants.
			var RENDER_DISTANCE 	= 2000;		// Render distance and grid size in pixels

			var GRID_SPACE 			= 50;	// Grid space in pixels
			var GRID_POSITION_Y 	= -100;	// Grid position below origin.

			var CAM_ZOOM_SPEED 		= 10;	// Rate of camera radius change.
			var MIN_CAM_RADIUS 		= 20; 	// Minimum camera distance from origin (0,0,0).
			var CAM_START_RADIUS 	= 200;  // Starting camera distance from origin (0,0,0).
			var MAX_CAM_RADIUS 		= 300; 	// Maximum camera distance from origin (0,0,0).

			var CAM_START_POLAR 	= Math.PI / 12;
			var CAM_START_AZIMUTH 	= Math.PI / 12; 
			var CAM_ROTATE_SPEED 	= 0.02; // Camera rotation speed radians per key press

			var UNIT_CUBE_SIZE = 10;
			var CUBE_SPACE = 1;
			var CUBE_ROTATE_SPEED 	= Math.PI / 128; // Cube rotation speeed radians per frame

			var ORIGIN = new THREE.Vector3(0, 0, 0); 
			var XAXIS = new THREE.Vector3(1, 0, 0);		// Rotate on this axis for pitch. Translate to move right (left).
			var YAXIS = new THREE.Vector3(0, 1, 0);		// Rotate on this axis for yaw. Translate to move up (down).
			var ZAXIS = new THREE.Vector3(0, 0, 1);		// Rotate on this for roll. Translate to move backward (forward).

			// Setup keyboard button name to keycode mapping.
			var keyNames = {
				32: "space", 
				37: "left", 
				38: "up", 
				39: "right", 
				40: "down", 
				65: "a", 
				66: "b",
				68: "d",
				70: "f",
				76: "l",
				82: "r", 
				83: "s",
				85: "u", 
				87: "w",
				88: "x",
				89: "y",
				90: "z"
			}; 

			// Create variables for orbital camera control.
			var camPolarAngle = CAM_START_POLAR; 				// Horizontal rotation (longitude) in radians
			var camAzimuthAngle = CAM_START_AZIMUTH;			// Vertical rotation (latitude) in radians
			var camRadius = CAM_START_RADIUS;					// Distance from origin (0,0,0) to camera

			// Respond to key presses.
			$("body").keydown(function (event) {
				// Use arrow keys to rotate camera.
				if (keyNames[event.keyCode] === "left") {
					camPolarAngle += -CAM_ROTATE_SPEED;
				}
				if (keyNames[event.keyCode] === "right") {
					camPolarAngle += CAM_ROTATE_SPEED;
				}
				if (keyNames[event.keyCode] === "up") {
					if ( camAzimuthAngle < Math.PI / 2 ) {
						camAzimuthAngle += CAM_ROTATE_SPEED;
					} else {
						camAzimuthAngle = Math.PI / 2; 
					}
				}
				if (keyNames[event.keyCode] === "down") {
					if ( camAzimuthAngle > -Math.PI / 2 ) {
						camAzimuthAngle -= CAM_ROTATE_SPEED;
					} else {
						camAzimuthAngle = -Math.PI / 2; 
					}
				}
				// Use w and s keys to zoom camera in and out.
				if (keyNames[event.keyCode] === "w") {
					if ( camRadius > MIN_CAM_RADIUS ) {
						camRadius -= CAM_ZOOM_SPEED;
					} else {
						camRadius = MIN_CAM_RADIUS; 
					}
				}
				if (keyNames[event.keyCode] === "s") {
					if ( camRadius < MAX_CAM_RADIUS ) {
						camRadius += CAM_ZOOM_SPEED;
					} else {
						camRadius = MAX_CAM_RADIUS; 
					}
				}
				// Use shift key to reverse face rotation.
				var rotDir = 1;
				if (event.shiftKey) {
					rotDir = -1;
				} else {
					rotDir = 1;
				}
				// Use f, r, u, l, b, d keys to trigger face rotations.
				if (keyNames[event.keyCode] === "f") {
					multiCube3.rotateFacePartial( multiCube3.faceF, ZAXIS, -rotDir * CUBE_ROTATE_SPEED );
				}
				if (keyNames[event.keyCode] === "r") {
					multiCube3.rotateFacePartial( multiCube3.faceR, XAXIS, -rotDir * CUBE_ROTATE_SPEED );
				}
				if (keyNames[event.keyCode] === "u") {
					multiCube3.rotateFacePartial( multiCube3.faceU, YAXIS, -rotDir * CUBE_ROTATE_SPEED );
				}
				if (keyNames[event.keyCode] === "l") {
					multiCube3.rotateFacePartial( multiCube3.faceL, XAXIS, rotDir * CUBE_ROTATE_SPEED );
				}
				if (keyNames[event.keyCode] === "b") {
					multiCube3.rotateFacePartial( multiCube3.faceB, ZAXIS, rotDir * CUBE_ROTATE_SPEED );
				}
				if (keyNames[event.keyCode] === "d") {
					multiCube3.rotateFacePartial( multiCube3.faceD, YAXIS, rotDir * CUBE_ROTATE_SPEED );
				}
				// Use space to trigger face updates.
				if (keyNames[event.keyCode] === "space") {
					multiCube3.snapToGrid();
					multiCube3.updateCubeNumAt();
					multiCube3.updateFaces();
				}
			})

			// Create a camera.
			var camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, RENDER_DISTANCE );
			camera.position.x = 0;
			camera.position.y = 0;
			camera.position.z = CAM_START_RADIUS;
			camera.lookAt(ORIGIN);

			// Create a scene and add fog to it
			var scene = new THREE.Scene();
			scene.fog = new THREE.FogExp2( 0xa8d7ff, 0.0008 );

			// Let there be light!
			var sunLight = new THREE.DirectionalLight( 0xffffff, 0.2 );
			sunLight.position.set(200, 1000, 200);
			sunLight.castShadow = true;
			sunLight.shadow.camera.near = 1;
			sunLight.shadow.camera.far = RENDER_DISTANCE;
			sunLight.shadow.camera.left = -RENDER_DISTANCE / 10;
			sunLight.shadow.camera.right = RENDER_DISTANCE / 10;
			sunLight.shadow.camera.bottom = -RENDER_DISTANCE / 10;
			sunLight.shadow.camera.top = RENDER_DISTANCE / 10;
			sunLight.shadow.mapSize.width = RENDER_DISTANCE / 10;
			sunLight.shadow.mapSize.height = RENDER_DISTANCE / 10;
			scene.add(sunLight);

			var ambientLight = new THREE.AmbientLight( 0xffffff, 2);
			scene.add(ambientLight)

			// Create plane and grid for ground.
			var grid = new THREE.GridHelper( 10*RENDER_DISTANCE, 10*RENDER_DISTANCE/GRID_SPACE, 0xd00000, 0x101010 );
			grid.position.y = GRID_POSITION_Y;
			scene.add(grid);

			var planeGeo = new THREE.PlaneGeometry( 10*RENDER_DISTANCE, 10*RENDER_DISTANCE, 100, 100 );
			var planeMat = new THREE.MeshStandardMaterial( { color: 0x009900 });					
			var planeGround = new THREE.Mesh( planeGeo, planeMat );
			planeGround.rotation.x = -Math.PI / 2;
			planeGround.position.y = GRID_POSITION_Y - 2;
			scene.add(planeGround);
			planeGround.receiveShadow = true; 

			// MultiCube3
			// Define a 3x3x3 array of multi-colored cubes
			// Location # used in this.cubeNumAt is as follows: 
			// Front face (blue center)
			//	   24 25 26
			//     21 22 23
			//     18 19 20
			// Middle slice
			//	   15 16 17
			//     12 13 14
			//      9 10 11			
			// Back face (green center) as viewed from front
			// 		6  7  8
			// 		3  4  5
			// 		0  1  2
			// Centers of faces are: 
			//   4 = green, 10 = white, 12 = orange 
			// 	13 = (true center of MultiCube3) 
			// 	14 = red, 16 = yellow, 22 = blue
			var MultiCube3 = function ( unitCubeSize, unitCubeSpace ) {
				this.unitCubeSize = unitCubeSize;
				this.unitCubeSpace = unitCubeSpace; 
				this.gridPitch = unitCubeSize + unitCubeSpace;
				this.unitGeo = new THREE.BoxGeometry( unitCubeSize, unitCubeSize, unitCubeSize );
				this.unitGeo.faces[0].color.setHex( 0xff0000 );	// Red
				this.unitGeo.faces[1].color.setHex( 0xff0000 ); // Red
				this.unitGeo.faces[2].color.setHex( 0xff8c00 ); // Orange
				this.unitGeo.faces[3].color.setHex( 0xff8c00 ); // Orange
				this.unitGeo.faces[4].color.setHex( 0xffff00 ); // Yellow
				this.unitGeo.faces[5].color.setHex( 0xffff00 ); // Yellow
				this.unitGeo.faces[6].color.setHex( 0xffffff ); // White
				this.unitGeo.faces[7].color.setHex( 0xffffff ); // White
				this.unitGeo.faces[8].color.setHex( 0x0000ff ); // Blue
				this.unitGeo.faces[9].color.setHex( 0x0000ff ); // Blue
				this.unitGeo.faces[10].color.setHex( 0x00cc11 ); // Green
				this.unitGeo.faces[11].color.setHex( 0x00cc11 ); // Green
				this.unitMat = new THREE.MeshStandardMaterial( { vertexColors: THREE.FaceColors } );

				this.cubes = [];
				this.cubeNumAt = [];
				var i = 0;
				for (var z = 0; z <= 2; z++) {
					for (var y = 0; y <= 2; y++) {
						for (var x = 0; x <= 2; x++) {
							this.cubes.push(new THREE.Mesh( this.unitGeo, this.unitMat ));
							this.cubes[i].position.x = (x - 1) * (this.unitCubeSize + this.unitCubeSpace);
							this.cubes[i].position.y = (y - 1) * (this.unitCubeSize + this.unitCubeSpace);
							this.cubes[i].position.z = (z - 1) * (this.unitCubeSize + this.unitCubeSpace);
							this.cubes[i].castShadow = true;
							this.cubeNumAt[i] = i;
							i++;
						}; 
					}; 
				}; 

				this.updateFaces();
			}; 

			// Define a method for adding a MultiCube3 to a scene.
			MultiCube3.prototype.addToScene = function( scene ) {
				for (var i = 0; i <= 26; i++) {
					scene.add(this.cubes[i]);
				};
			};

			// Define a method for rotating a face of a MultiCube3.
			MultiCube3.prototype.rotateFacePartial = function( face, axis, angle ) {
				var i = j = k = 0;
				var q = new THREE.Quaternion();
				q.setFromAxisAngle(axis, angle);
				for (i=0; i<=2; i++) {
					for (j=0; j<=2; j++) {
							k = face[i][j];
							this.cubes[k].applyQuaternion(q);
							this.cubes[k].position.applyQuaternion(q);
					};
				};
			}; 

			MultiCube3.prototype.rotateFace = function( faceName, stepCount ) {
				switch(faceName) {
					case "F":
						face = this.faceF;
				}				
				for (var i=0; i<=stepCount; i++) {
					this.rotateFacePartial( face, axis, angle );
				};
			};

			MultiCube3.prototype.snapToGrid = function() {
				// Snaps unit cube locations and orientations to force on-grid and on-axis.
				for (var i=0; i<=26; i++) {
					// Snap X position
					if ( this.cubes[i].position.x > this.gridPitch / 2 ) {
						this.cubes[i].position.x = this.gridPitch;
					} else if ( this.cubes[i].position.x < -this.gridPitch / 2 ) {
						this.cubes[i].position.x = -this.gridPitch;						
					} else {
						this.cubes[i].position.x = 0;
					}
					// Snap Y position
					if ( this.cubes[i].position.y > this.gridPitch / 2 ) {
						this.cubes[i].position.y = this.gridPitch;
					} else if ( this.cubes[i].position.y < -this.gridPitch / 2 ) {
						this.cubes[i].position.y = -this.gridPitch;						
					} else {
						this.cubes[i].position.y = 0;
					}
					// Snap Z position
					if ( this.cubes[i].position.z > this.gridPitch / 2 ) {
						this.cubes[i].position.z = this.gridPitch;
					} else if ( this.cubes[i].position.z < -this.gridPitch / 2 ) {
						this.cubes[i].position.z = -this.gridPitch;						
					} else {
						this.cubes[i].position.z = 0;
					}
					// Snap X rotation
					if ( this.cubes[i].rotation.x < -3 * Math.PI / 4 ) {
						this.cubes[i].rotation.x = Math.PI;
					} else if ( this.cubes[i].rotation.x < -Math.PI / 4 ) {
						this.cubes[i].rotation.x = -Math.PI / 2;
					} else if ( this.cubes[i].rotation.x < Math.PI / 4 ) {
						this.cubes[i].rotation.x = 0;
					} else if ( this.cubes[i].rotation.x < 3 * Math.PI / 4 ) {
						this.cubes[i].rotation.x = Math.PI / 2;
					} else {
						this.cubes[i].rotation.x = Math.PI;
					}
					// Snap Y rotation
					if ( this.cubes[i].rotation.y < -3 * Math.PI / 4 ) {
						this.cubes[i].rotation.y = Math.PI;
					} else if ( this.cubes[i].rotation.y < -Math.PI / 4 ) {
						this.cubes[i].rotation.y = -Math.PI / 2;
					} else if ( this.cubes[i].rotation.y < Math.PI / 4 ) {
						this.cubes[i].rotation.y = 0;
					} else if ( this.cubes[i].rotation.y < 3 * Math.PI / 4 ) {
						this.cubes[i].rotation.y = Math.PI / 2;
					} else {
						this.cubes[i].rotation.y = Math.PI;
					}
					// Snap Z rotation
					if ( this.cubes[i].rotation.z < -3 * Math.PI / 4 ) {
						this.cubes[i].rotation.z = Math.PI;
					} else if ( this.cubes[i].rotation.z < -Math.PI / 4 ) {
						this.cubes[i].rotation.z = -Math.PI / 2;
					} else if ( this.cubes[i].rotation.z < Math.PI / 4 ) {
						this.cubes[i].rotation.z = 0;
					} else if ( this.cubes[i].rotation.z < 3 * Math.PI / 4 ) {
						this.cubes[i].rotation.z = Math.PI / 2;
					} else {
						this.cubes[i].rotation.z = Math.PI;
					}
				}
			}

			MultiCube3.prototype.updateCubeNumAt = function() {
				// Determines location # for each cube and update cubeNumAt array accordingly.
				// Assumes unit cube positions have already been snapped to grid so that unit cube
				//    positions should be integer multiples of (unitCubeSize + unitCubeSpace).
				var gridX = 0;  // X grid position from 0 to 2.
				var gridY = 0;  // Y grid position from 0 to 2.
				var gridZ = 0;  // Z grid position from 0 to 2.
				var locNum = 0;		// Location # from 0 to 26.
				for (var i=0; i<=26; i++) {
					gridX = ( this.cubes[i].position.x / this.gridPitch ) + 1; 
					gridY = ( this.cubes[i].position.y / this.gridPitch ) + 1; 
					gridZ = ( this.cubes[i].position.z / this.gridPitch ) + 1; 
					locNum = 9*gridZ + 3*gridY + gridX;
					this.cubeNumAt[locNum] = i;
				};
			};

			MultiCube3.prototype.updateFaces = function() {
				// Updates all 6 face arrays using cubeNumAt.
				// Assumes this.cubeNumAt has already been updated.
				this.faceF = [		// Define front face (blue).
					[this.cubeNumAt[24], this.cubeNumAt[25], this.cubeNumAt[26]], 
					[this.cubeNumAt[21], this.cubeNumAt[22], this.cubeNumAt[23]], 
					[this.cubeNumAt[18], this.cubeNumAt[19], this.cubeNumAt[20]] 
				];
				this.faceR = [		// Define right face (red).
					[this.cubeNumAt[26], this.cubeNumAt[17], this.cubeNumAt[8]], 
					[this.cubeNumAt[23], this.cubeNumAt[14], this.cubeNumAt[5]], 
					[this.cubeNumAt[20], this.cubeNumAt[11], this.cubeNumAt[2]] 
				];
				this.faceU = [		// Define up face (yellow).
					[this.cubeNumAt[6],  this.cubeNumAt[7],  this.cubeNumAt[8]], 
					[this.cubeNumAt[15], this.cubeNumAt[16], this.cubeNumAt[17]], 
					[this.cubeNumAt[24], this.cubeNumAt[25], this.cubeNumAt[26]]
				];
				this.faceL = [		// Define left face (orange).
					[this.cubeNumAt[6], this.cubeNumAt[15], this.cubeNumAt[24]], 
					[this.cubeNumAt[3], this.cubeNumAt[12], this.cubeNumAt[21]], 
					[this.cubeNumAt[0], this.cubeNumAt[9],  this.cubeNumAt[18]]
				];
				this.faceB = [		// Define back face (green).
					[this.cubeNumAt[8], this.cubeNumAt[7], this.cubeNumAt[6]], 
					[this.cubeNumAt[5], this.cubeNumAt[4], this.cubeNumAt[3]], 
					[this.cubeNumAt[2], this.cubeNumAt[1], this.cubeNumAt[0]]
				];
				this.faceD = [		// Define down face (white).
					[this.cubeNumAt[18], this.cubeNumAt[19], this.cubeNumAt[20]], 
					[this.cubeNumAt[9],  this.cubeNumAt[10], this.cubeNumAt[11]], 
					[this.cubeNumAt[0],  this.cubeNumAt[1],  this.cubeNumAt[2]]
				];
			};

			// Create the MultiCube3 and add it to the scene.			
			multiCube3 = new MultiCube3( UNIT_CUBE_SIZE, CUBE_SPACE ); 
			multiCube3.addToScene( scene );

			// Create a renderer.
			var renderer = new THREE.WebGLRenderer(); 
			renderer.setSize( window.innerWidth - 10, window.innerHeight - 10 ); // Shrunk by 10 pixels to avoid shifts in screen when arrows are used.
			renderer.setClearColor( 0xa8d7ff, 1 ); // Set clear color to sky blue.
			renderer.shadowMap.enabled = true;
			renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
			document.body.appendChild( renderer.domElement );

			// Repeatedly render the scene from the camera's point of view.
			renderer.render( scene, camera );
			function animate() {
				requestAnimationFrame( animate );

				// Move the camera according to user command.
				camera.position.z = camRadius * Math.cos(camAzimuthAngle) * Math.cos(camPolarAngle);
				camera.position.x = camRadius * Math.cos(camAzimuthAngle) * Math.sin(camPolarAngle);
				camera.position.y = camRadius * Math.sin(camAzimuthAngle);
				camera.lookAt(ORIGIN); 

				renderer.render( scene, camera );
			}
			animate(); 
		</script>
	</body>
</html>
